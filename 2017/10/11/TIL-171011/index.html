<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>TIL_171011 객체(Number, Math), 정규표현식, 배열 | Sunny&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="자주사용하는, 또는 기억해야할 특징이 있는 Built-in Object Number 객체A) Number Property Number.EPSILON부동소수점 산술 연산 비교는 정확한 값을 기대하기 어렵다. 정수는 2진법으로 오차없이 저장이 가능하지만 부동소수점을 표현하는 가장 널리 쓰이는 표준인 IEEE 754은 2진법으로 변환시 무한소수가 되어 미세한 오">
<meta property="og:type" content="article">
<meta property="og:title" content="TIL_171011 객체(Number, Math), 정규표현식, 배열">
<meta property="og:url" content="https://SunnySunhwa.github.io/2017/10/11/TIL-171011/index.html">
<meta property="og:site_name" content="Sunny&#39;s Blog">
<meta property="og:description" content="자주사용하는, 또는 기억해야할 특징이 있는 Built-in Object Number 객체A) Number Property Number.EPSILON부동소수점 산술 연산 비교는 정확한 값을 기대하기 어렵다. 정수는 2진법으로 오차없이 저장이 가능하지만 부동소수점을 표현하는 가장 널리 쓰이는 표준인 IEEE 754은 2진법으로 변환시 무한소수가 되어 미세한 오">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2017-10-11T11:52:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TIL_171011 객체(Number, Math), 정규표현식, 배열">
<meta name="twitter:description" content="자주사용하는, 또는 기억해야할 특징이 있는 Built-in Object Number 객체A) Number Property Number.EPSILON부동소수점 산술 연산 비교는 정확한 값을 기대하기 어렵다. 정수는 2진법으로 오차없이 저장이 가능하지만 부동소수점을 표현하는 가장 널리 쓰이는 표준인 IEEE 754은 2진법으로 변환시 무한소수가 되어 미세한 오">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-TIL-171011" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TIL_171011 객체(Number, Math), 정규표현식, 배열
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p><strong>자주사용하는, 또는 기억해야할 특징이 있는 Built-in Object</strong></p>
<h1 id="Number-객체"><a href="#Number-객체" class="headerlink" title="Number 객체"></a>Number 객체</h1><h2 id="A-Number-Property"><a href="#A-Number-Property" class="headerlink" title="A) Number Property"></a>A) Number Property</h2><ol>
<li><strong>Number.EPSILON</strong><br>부동소수점 산술 연산 비교는 정확한 값을 기대하기 어렵다. 정수는 2진법으로 오차없이 저장이 가능하지만 부동소수점을 표현하는 가장 널리 쓰이는 표준인 IEEE 754은 2진법으로 변환시 무한소수가 되어 미세한 오차가 발생할 수밖에 없는 구조적 한계를 갖는다.</li>
</ol>
<p><strong>따라서 부동소수점의 비교는 Number.EPSILON을 사용하여 비교 기능을 갖는 함수를 작성해야함</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);        <span class="comment">// 0.30000000000000004</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false!!!</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  <span class="comment">// Math.abs는 절댓값을 반환한다.</span></div><div class="line">  <span class="comment">// 즉 a와 b의 차이가 JavaScript에서 표현할 수 있는 가장 작은 수인 Number.EPSILON보다 작으면 같은 수로 인정할 수 있다.</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>));</div></pre></td></tr></table></figure>
<h2 id="B-Number-prototype-method"><a href="#B-Number-prototype-method" class="headerlink" title="B) Number.prototype.method"></a>B) Number.prototype.method</h2><ol>
<li>Number.prototype.toFixed();<br>: 반올림, 소수점 자리수 지정</li>
<li>Number.prototype.toPrecision();<br>: 정수, 소수까지 포함한 숫자 전체의 자리수</li>
</ol>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math는 별도의 생성자 없이 정적인 프로퍼티와 메소드만을 제공함</p>
<h2 id="1-Math-property"><a href="#1-Math-property" class="headerlink" title="1) Math property"></a>1) Math property</h2><ol>
<li>Math.PI<br>: 파이값 반환<h2 id="2-Math-method"><a href="#2-Math-method" class="headerlink" title="2) Math method"></a>2) Math method</h2></li>
<li>Math.round();<br>: 반올림, 음수/양수의 반올림 기준이 다름 (eg. -20.5는 반내림)  </li>
<li>Math.ceil();<br>: 무조건 반올림  </li>
<li>Math.floor();<br>: 무조건 반내림</li>
<li><p>Math.random();<br>: 0과 1미만의 수가 랜덤하게 나옴</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 랜덤 정수</span></div><div class="line"><span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>); <span class="comment">// 1 ~ 10</span></div><div class="line"><span class="built_in">console</span>.log(randomNum);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Math.max(); Math.min();</strong><br>: 인수 중에서 큰수/작은수를 반환</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//기본안</span></div><div class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">//기본안으로 사용하기에는 매번 인자를 입력해줘야함.</span></div><div class="line"><span class="comment">//인자를 this로 자동으로 주기 위해</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</div><div class="line"><span class="comment">//맥스 함수를 호출하라, 단, this는 null / 인자는 arr이라는 배열로 라는 의미</span></div><div class="line"><span class="comment">//배열을 풀어서 기본안처럼 이용되게 하라 -&gt; 1, 2, 3</span></div><div class="line"><span class="comment">//항상 null인것은 아님, 때에 따라 달라질 수 있기에 this를 확인하고 사용해야함</span></div><div class="line"><span class="comment">// apply와 call은 함수를 사용하고자 할때 쓰임, 부가적으로 this를 던져줄수있다는 특징</span></div><div class="line"><span class="comment">// apply와 call의 다른점은 두번째 인자가 배열이냐 리스트이냐</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="정규표현식-RegExp"><a href="#정규표현식-RegExp" class="headerlink" title="정규표현식 (RegExp)"></a>정규표현식 (RegExp)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = <span class="string">'This is Pen'</span>;</div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/is/ig</span>;</div><div class="line"><span class="comment">// 원하는 정규표현식을 담은 객체를 만들어서 정규표현식 객체의 메서드를 활용하기 위함</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 원하는 정규표현식을 담은 객체의 메서드 test를 활용</span></div><div class="line"><span class="built_in">console</span>.log(reg.test(target));</div><div class="line"><span class="comment">// String객체의 메서드를 활용 (스트링 객체 메서드를 활용하기때문에 인자값이 위와 다름)</span></div><div class="line"><span class="built_in">console</span>.log(target.match(reg));</div></pre></td></tr></table></figure>
<ul>
<li>RegExp객체의 메서드 활용안과 String객체의 메서드 활용안의 인자값이 다름</li>
</ul>
<h4 id="RegExp-객체-메소드"><a href="#RegExp-객체-메소드" class="headerlink" title="RegExp 객체 메소드"></a>RegExp 객체 메소드</h4><ul>
<li>test, exec ..<h4 id="String-객체-메소드"><a href="#String-객체-메소드" class="headerlink" title="String 객체 메소드"></a>String 객체 메소드</h4></li>
<li>match, replace, search, split ..</li>
</ul>
<h2 id="1-Flag"><a href="#1-Flag" class="headerlink" title="1) Flag"></a>1) Flag</h2><ol>
<li>i :    Ignore Case    대소문자를 구별하지 않고 검색</li>
<li>g :    Global    문자열 내의 모든 패턴을 검색</li>
<li>m :    Multi Line    문자열의 행이 바뀌더라도 검색을 계속</li>
</ol>
<h2 id="2-Pattern-‘’생략"><a href="#2-Pattern-‘’생략" class="headerlink" title="2) Pattern (‘’생략)"></a>2) Pattern (‘’생략)</h2><ol>
<li>. : 임의의 문자 하나</li>
<li>‘+’ : 대상문자가 한번이상 반복되는 것</li>
<li>| : 또는</li>
<li>[] : 안에 있는 문자가 or로 연결 (eg. /a+|b+/  =  /[ab]+/)</li>
<li>‘[-]’: 범위 지정</li>
<li>^: 특정단어로 시작하는지</li>
<li>$: 특정단어로 끝나는지</li>
<li>\s : 공백</li>
<li>{a,b}: 최소a~ 최대b자리의 수</li>
</ol>
<hr>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>1개의 변수에 여러개의 값을 <strong>순차적</strong> 으로 저장할때 사용</li>
<li>배열 리터럴/생성자 함수로 사용할 수 있으나, 배열 리터럴 역시 내부적으로는 생성자함수로 동작 -&gt; 배열 리터럴로 많이 활용</li>
<li>어떤 자료형(배열까지) 담을 수 있음</li>
<li>재할당으로 배열의 요소 추가/삭제가 가능</li>
<li>삭제는 요소 값만 삭제, 요소 수는 변경X -&gt; 메소드를 활용해야함</li>
</ul>
<h2 id="1-Array-method"><a href="#1-Array-method" class="headerlink" title="1) Array method"></a>1) Array method</h2><h4 id="1-Array-prototype-concat"><a href="#1-Array-prototype-concat" class="headerlink" title="1. Array.prototype.concat()"></a>1. Array.prototype.concat()</h4><ul>
<li>인수로 넘어온 배열/값을 요소로 추가</li>
<li>원본 배열은 변하지X -&gt; 리턴 값으로 받아줘서 반환해야함</li>
</ul>
<h4 id="2-Array-prototype-join"><a href="#2-Array-prototype-join" class="headerlink" title="2. Array.prototype.join()"></a>2. Array.prototype.join()</h4><ul>
<li>배열 요소 전체를 연결하여 생성한 문자열을 반환</li>
</ul>
<h4 id="3-Array-prototype-pop-push"><a href="#3-Array-prototype-pop-push" class="headerlink" title="3. Array.prototype.pop() / push()"></a>3. Array.prototype.pop() / push()</h4><ul>
<li>배열을 스택처럼 동작하게 하여 마지막 요소를 제거하거나 추가</li>
<li><strong>원본 배열이 변경됨</strong></li>
<li>push와 concat의 차이점은 concat은 배열이 풀어져서 요소로 들어가게 되고, push는 배열이 하나의 요소로</li>
<li>단, push/unshift 메소드는 퍼포먼스상 좋지 않음 (100번이상 정도? 고려해봐야..)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line">arr.push(<span class="number">6</span>);</div><div class="line">arr[arr.length] = <span class="number">6</span>; <span class="comment">// 43% faster</span></div><div class="line"></div><div class="line">arr.unshift(<span class="number">0</span>);</div><div class="line">[<span class="number">0</span>].concat(arr); <span class="comment">// 98% faster</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-Array-prototype-slice-start-end"><a href="#4-Array-prototype-slice-start-end" class="headerlink" title="4. Array.prototype.slice(start,end)"></a>4. <em>Array.prototype.slice(start,end)</em></h4><ul>
<li>start부터 end인덱스 미만의 요소 반환</li>
<li><strong>인자를 주지 않으면 그대로 복사본 생성</strong></li>
<li>객체는 참조값을 복사하기 때문에 값이 그대로 복사 안됨 -&gt; slice를 통해 원본은 그대로 두면서 복사본 생성이 가능</li>
</ul>
<h4 id="5-Array-prototype-splice-start-ea-new-item"><a href="#5-Array-prototype-splice-start-ea-new-item" class="headerlink" title="5. Array.prototype.splice(start,ea,new item)"></a>5. <em>Array.prototype.splice(start,ea,new item)</em></h4><ul>
<li>기존 배열 요소(값과 자리 전체)를 제거하고 그 위치에 새로운 요소 추가 가능</li>
<li><strong>원본 배열 변경</strong></li>
<li>혹은 제거 없이 (제거갯수 0) 새로운 요소만 추가도 가능 (apply로 배열을 풀어서 리스트화해야)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</div><div class="line"></div><div class="line"><span class="comment">// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환</span></div><div class="line"><span class="keyword">var</span> res = items.splice(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 원본 배열이 변경된다.</span></div><div class="line"><span class="built_in">console</span>.log(items); <span class="comment">// [ 'one', 'four' ]</span></div><div class="line"><span class="comment">// 제거한 요소가 배열로 반환된다.</span></div><div class="line"><span class="built_in">console</span>.log(res);   <span class="comment">// [ 'two', 'three' ]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = [<span class="string">'one'</span>, <span class="string">'four'</span>];</div><div class="line"></div><div class="line"><span class="comment">// items[1]부터 0개의 요소를 제거하고 그자리(items[1])에 새로운 배열를 추가한다. 제거된 요소가 반환된다.</span></div><div class="line"><span class="comment">// items.splice(1, 0, ['two', 'three']); // [ 'one', [ 'two', 'three' ], 'four' ]</span></div><div class="line"><span class="built_in">Array</span>.prototype.splice.apply(items, [<span class="number">1</span>, <span class="number">0</span>].concat([<span class="string">'two'</span>, <span class="string">'three'</span>]));</div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="comment">// items.splice(1, 0, ...['two', 'three']);</span></div><div class="line"></div><div class="line"><span class="comment">//apply를 사용함으로써 아래와 같은 결과값 얻을 수 있음</span></div><div class="line"><span class="built_in">console</span>.log(items); <span class="comment">// [ 'one', 'two', 'three', 'four' ]</span></div></pre></td></tr></table></figure>
<h4 id="6-Array-prototype-sort"><a href="#6-Array-prototype-sort" class="headerlink" title="6. Array.prototype.sort()"></a>6. Array.prototype.sort()</h4><ul>
<li>배열 요소 정렬</li>
<li>문자열은 오름차순(sort)/내림차순(reverse)로 정렬</li>
<li>요소가 숫자인 경우의 정렬은 아래 방법으로<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span>];</div><div class="line"></div><div class="line">points.sort();</div><div class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 1, 10, 100, 25, 40, 5 ]</span></div><div class="line"></div><div class="line"><span class="comment">// Syntax : array.sort(compareFunction)</span></div><div class="line"></div><div class="line"><span class="comment">// 숫자 배열 오름차순 정렬</span></div><div class="line"><span class="comment">// compareFunction의 반환값이 0보다 작은 경우, a를 우선한다.</span></div><div class="line">points.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</div><div class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 1, 5, 10, 25, 40, 100 ]</span></div><div class="line"></div><div class="line"><span class="comment">// 숫자 배열에서 최소값 취득</span></div><div class="line"><span class="built_in">console</span>.log(points[<span class="number">0</span>]); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 숫자 배열 내림차순 정렬</span></div><div class="line"><span class="comment">// compareFunction의 반환값이 0보다 큰 경우, b를 우선한다.</span></div><div class="line">points.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;);</div><div class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 100, 40, 25, 10, 5, 1 ]</span></div><div class="line"></div><div class="line"><span class="comment">// 숫자 배열에서 최대값 취득</span></div><div class="line"><span class="built_in">console</span>.log(points[<span class="number">0</span>]); <span class="comment">// 100</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-Array-prototype-forEach-함수-this"><a href="#7-Array-prototype-forEach-함수-this" class="headerlink" title="7. Array.prototype.forEach(함수, this)*"></a>7. <em>Array.prototype.forEach(함수, this)</em>*</h4><ul>
<li>배열을 순회하며 인자로 주어진 함수를 실행(콜백함수)</li>
<li>이 콜백함수의 인자로 배열 요소값, 요소 인덱스, 배열 자체 전달 가능</li>
<li>즉, <strong>forEach(콜백함수(item, index, array){},this);</strong></li>
<li>break문 사용 불가</li>
<li>forEach는 원본 배열을 변경하지 않음 -&gt; 하고싶으면 콜백함수의 3번째 함수 이용</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">testArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">  array[index] = <span class="built_in">Math</span>.pow(item, <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//활용된 배열(array)에 해당 값을 재할당 함으로써 원본배열 변경</span></div><div class="line"><span class="built_in">console</span>.log(testArray); <span class="comment">// [ 1, 4, 9, 16 ]</span></div></pre></td></tr></table></figure>
<ul>
<li>forEach문에 첫번째 인자(콜백함수), 두번째 인자로 this를 주어야만 생성할 객체의 this가 됨 (안써주면 this=window)</li>
</ul>
<h5 id="참고-this가-window가-아닌-경우"><a href="#참고-this가-window가-아닌-경우" class="headerlink" title="[참고] this가 window가 아닌 경우*"></a>[참고] this가 window가 아닌 경우*</h5><ol>
<li>메소드 내부 (this=호출한 객체)</li>
<li>생성자 함수 내부 (this=생성자 함수가 생성할 객체)<br>이 외의 경우는(콜백함수 내부) this=window</li>
</ol>
<h4 id="8-Array-prototype-map"><a href="#8-Array-prototype-map" class="headerlink" title="8. Array.prototype.map()*"></a>8. <em>Array.prototype.map()</em>*</h4><ul>
<li>forEach문과 다르게 배열의 각 요소를 가지고 실행하여 <em>새로운배열</em> 을 반환 (forEach는 그 요소를 가지고 실행하기만 함)</li>
<li>새로운 배열을 만드릭 때문에 꼭 return을 하여 새로운 배열에 결과 값을 반영됨 (forEach문엔 return이 없음)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2017/10/11/TIL-171011/" class="article-date">
  <time datetime="2017-10-11T11:50:20.000Z" itemprop="datePublished">2017-10-11</time>
</a>

        </li>
        
          <li>
            <span class="label">Category:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>


          </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2017/10/11/TIL-171010-test/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">TIL_171010 javascript기초 테스트</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
